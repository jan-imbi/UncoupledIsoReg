# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Minimize the entropic Wasserstein distance
#'
#'
#'
#' @param mu_vals,nu_vals numeric vector of values of discrete distribution
#' @param mu_probs,nu_probs numeric vector of probabilities of discrete distribution
#' @param p exponent of L_p distance
#'
#' @examples
#' Wp(c(1,2,3), c(1/3, 1/3, 1/3), c(2,3,4), c(1/4, 1/4, 1/2), 1)
#' @export
Wp <- function(mu_vals, mu_probs, nu_vals, nu_probs, p) {
    .Call(`_UncoupledIsoReg_Wp`, mu_vals, mu_probs, nu_vals, nu_probs, p)
}

#' Discrete distribution with 2 values.
#'
#' @param n number of observations.
#' @param a first value.
#' @param b second value.
#' @param p Let X ~ pbernoulli_custom. Then p = Probability(X=a).
#' @export
rbernoulli_custom <- function(n, a = -1, b = 1, p = 0.5) {
    .Call(`_UncoupledIsoReg_rbernoulli_custom`, n, a, b, p)
}

#' Discrete distribution with 2 values.
#'
#' @param x observations.
#' @param a first value.
#' @param b second value.
#' @param p Let X ~ pbernoulli_custom. Then p = Probability(X=a).
#' @export
pbernoulli_custom <- function(x, a, b, p) {
    .Call(`_UncoupledIsoReg_pbernoulli_custom`, x, a, b, p)
}

#' Minimize the entropic Wasserstein distance
#'
#'
#'
#' @param Y numeric vector of observations
#' @param A numeric vector of domain values where you expect most of the Y values to lie in
#' @param AV numeric vector of domain values which you allow the functions in the space you minimize over to take
#' @param P_D Jacobian of mu -> W_2(mu*D, pi_hat)
#' @param muStart starting values for minimization
#' @param maxIter maximum iteration number for gradient descent algorithm
#' @param minIter minimum iteration number for gradient descent algorithm
#' @param sinkhornIter maximum Sinkhorn iterations
#' @param eps entropic regularization constant
#' @param gammaStart starting gamma value for gradient descent algorithm. Only used in first descent step.
#' @param p exponent of L_p norm
#' @param sinkhornTol tolerance for stopping criterion in Sinkhorn algorithm
#' @param gradDescTol tolerance for stopping criterion in gradient descent algorithm based on euclidian distance to last
#' vector
#' @param fastSinkhorn logical, controls whether to use the fast Sinkhorn algorithm
#' @param pushforwardStart if TRUE, starts with nearest neighbour distribution to pi_hat instead of rep(1/n)
#' @param suppressOutput suppress output messages?
#' @param WThreshold tolerance for stopping criterion for gradient descent algorithm based on the Wasserstein distance
#'
#' @examples
#' library(tidyverse)
#' n <- 1000
#' x <- seq(0, 1, length.out = n)
#' m <- function(x) (2*(x- 0.5))^3
#' Y_no_error <-  m(x)
#' varepsilon <- rbernoulli_custom(n, a= -0.3, b= 0.3, p=0.5)
#' Y <- (Y_no_error + varepsilon) %>% sample(n)
#' dat <- tibble(x=x, Y=Y, Y_no_error = Y_no_error)
#' N <- round(sqrt(n))
#' A <- seq(-1.3, 1.3, length.out = N)
#' stepsize <- (A[2]-A[1]) / 2
#' A_V <-  A[which(-1 - stepsize <= A & A <= 1 + stepsize)]
#' p_ber <- function(x) pbernoulli_custom(x, a = -0.3, b = 0.3, p=0.5)
#' P <- matrix(rep(0, times = (N) * length(A_V)), nrow = N)
#' P[1, ] <- p_ber(A[2] - stepsize - A_V)
#' for (i in 2:(N-1)) {
#'     P[i,] <- p_ber(A[i + 1] - stepsize - A_V) - p_ber(A[i] - stepsize - A_V)
#' }
#' P[N, ] <- 1 - p_ber(A[N] - stepsize - A_V)
#'
#' l <-
#'    minimize_entropic_W(Y = Y,
#'                        A = A,
#'                        AV = A_V,
#'                        P_D = P,
#'                        suppressOutput = FALSE)
#' mu_hat <- list()
#' mu_hat[["vals"]] <- l$vals
#' mu_hat[["probs"]] <- l$probs
#' g_hat <- measure_to_smooth_iso(mu_hat, n)
#' dat <- bind_cols(dat, g_hat = g_hat)
#' ggplot(dat, aes(x=x, y=Y_no_error)) +
#'   geom_line(col="red") +
#'   scale_y_continuous("") +
#'   geom_line(aes(y=g_hat), col="blue")
#'
#' @import tidyverse
#' @export
minimize_entropic_W <- function(Y, A = NULL, AV = NULL, P_D = NULL, muStart = NULL, maxIter = 100L, minIter = 50L, sinkhornIter = 100L, eps = 0.01, gammaStart = .05, p = 1, sinkhornTol = 1e-12, gradDescTol = 1e-12, fastSinkhorn = TRUE, pushforwardStart = FALSE, suppressOutput = FALSE, WThreshold = 0) {
    .Call(`_UncoupledIsoReg_minimize_entropic_W`, Y, A, AV, P_D, muStart, maxIter, minIter, sinkhornIter, eps, gammaStart, p, sinkhornTol, gradDescTol, fastSinkhorn, pushforwardStart, suppressOutput, WThreshold)
}

laurentCondat <- function(y) {
    .Call(`_UncoupledIsoReg_laurentCondat`, y)
}

logStabSinkhorn_cpp <- function(a_, b, costMat_, eps, maxIter, tol) {
    .Call(`_UncoupledIsoReg_logStabSinkhorn_cpp`, a_, b, costMat_, eps, maxIter, tol)
}

Subgradient <- function(a_, b, M, eps, maxIter = 100L, tolerance = 1e-14) {
    .Call(`_UncoupledIsoReg_Subgradient`, a_, b, M, eps, maxIter, tolerance)
}

